### Часть 1. ПЕРВОНАЧАЛЬНАЯ РАЗВЕДКА

Из входных данных у нас имеются только IP-адреса двух машин на базе Kali Linux – 92.0.0.1 и 92.0.0.2. Все действия, произведенные в ходе тестирования на проникновение будут проводиться относительно машины с IP-адресом **92.0.0.1**. Используя имеющийся IP-адрес у одной из машин с Kali Linux, а также, принимая во внимание тот факт, что машины с Kali Linux имеют доступ к сети, которую необходимо проверить по заданию, было запущено сканирование сети по маске в **16 бит (/16)**. При этом процесс сканирования представляет собой **ping-сканирование заданного диапазона IP-адресов без разрешения DNS-имен**.

![ScreenShot](screenshots/1.png)

Собственно, нам удалось определить 4 потенциальные цели для дальнейшего развития атаки. Перед тем, как начинать разрабатывать дальнейший ход событий, выполним детальное сканирование отдельных найденных хостов

![ScreenShot](screenshots/2.png)

![ScreenShot](screenshots/3.png)

![ScreenShot](screenshots/4.png)

В следующем разделе приступим непосредственно к исследованию и захвату найденных хостов.

---
### Часть 2. ИССЛЕДОВАНИЕ ХОСТА С IP-АДРЕСОМ 92.0.3.67

В качестве отправной точки был выбран хост, на котором установлен PostgreSQL. В БД PostgreSQL есть стандартный пользователь **postgres** с одноименным паролем.

![ScreenShot](screenshots/5.png)

Вход выполнен успешно, поэтому сразу же были просмотрены имеющиеся базы данных:

![ScreenShot](screenshots/6.png)

> Кто такой john-gold...?

Здесь же средствами самого PostgreSQL можно манипулировать файлами и директориями:

![ScreenShot](screenshots/7.png)

![ScreenShot](screenshots/8.png)

![ScreenShot](screenshots/9.png)

Для начала была просмотрена директория */home*, где находится директория */user*. Далее были просмотрены файлы в данной директории, после чего найдены первый флаг и пароль ***qwertyuiop***, скорее всего от пользователя *user*, который присутствует на данном хосте. Соответственно, мы выяснили, что по логину и паролю ***postgres*:*postgres*** можно также войти через ssh, но нам заходить таким способом нет необходимости, т.к. у нас, предположительно, уже есть данные от пользователя *user*.

![ScreenShot](screenshots/10.png)

Так как, в теории, пароль от пользователя *user* мы узнали, то пытаемся войти по SSH на исследуемый хост от имени данного пользователя:

![ScreenShot](screenshots/11.png)

Теперь нам необходимо повысить привилегии на данном хосте, чтобы получить root-флаг. Посмотрим, какие команды user может выполнять относительно sudo:

![ScreenShot](screenshots/12.png)

Собственно, у нас имеется полный спектр возможностей запуска команд на данном хосте, поэтому способов повысить привилегии достаточно, как минимум, можно посмотреть интересующую нас директорию просто указывая в начале «*sudo*»

![ScreenShot](screenshots/13.png)

![ScreenShot](screenshots/14.png)

Можно просто написать *sudo bash*, тем самым сменив пользователя user на root и прочитав root-флаг:

![ScreenShot](screenshots/15.png)

Помимо всего прочего, на хосте были найдены SSH-ключи

![ScreenShot](screenshots/16.png)

Также в домашней директории пользователя *user* был просмотрен файл ***.bash\_history***. В нем удалось найти хост и пользователя, к которым относятся найденные ранее SSH-ключи

![ScreenShot](screenshots/17.png)

Собственно ниже представлена успешная авторизация через SSH на хост с IP-адресом **92.0.2.254**.

![ScreenShot](screenshots/18.png)

Найденные флаги на хосте ***92.0.3.67***:
- ***User-флаг***: fe5f74939c7d725d27a2ad0142be492a
- ***Root-флаг***: ff7544810bb65c89576593649f83fe3c

---
### Часть 3. ИССЛЕДОВАНИЕ ХОСТА С IP-АДРЕСОМ 92.0.2.254

На хосте с IP-адресом 92.0.2.254 с помощью Nmap удалось обнаружить FTP-сервер. При этом, можно заметить, что доступен вход на данный сервер через *anonymous* (без пароля). Собственно, подключившись к FTP-серверу по вышеупомянутым данным, не удалось обнаружить никаких файлов, в том числе попытавшись переместиться между директориями:

![ScreenShot](screenshots/19.png)

В предыдущей главе мы получили доступ к машине с IP-адресом 92.0.2.254. После этого был исследован файл */etc/passwd* на наличие других пользователей в системе:

![ScreenShot](screenshots/20.png)

На данном этапе мы можем прочитать user-флаг:

![ScreenShot](screenshots/21.png)

Далее нам необходимо повысить привилегии на данной машине, чтобы прочитать root-флаг. Пробуем посмотреть sudo-привилегии:

![ScreenShot](screenshots/22.png)

И вот тут мы понимаем, что мы не знаем пароль от учетной записи *user*, поэтому нам надо что-то с этим попробовать сделать. Из вариантов:
1. Узнать пароль;
2. Повысить привилегии относительно другой УЗ.

Попробуем реализовать первую догадку. Для начала обратим внимание на файл *pass\_manager*. Попробуем его запустить и увидим, что при запуске требуется подать на вход пароль. Собственно, если его подавать, то программа производить валидацию пароля:

![ScreenShot](screenshots/23.png)

Программа сообщила нам о том, что в ней используется функция *strcmp()* для проверки пароля (сравнение с оригинальным паролем). Попробуем получить исходный пароль, зареверсив данную программу, но для начала скопируем файл к себе на Kali Linux. Для воспроизведения данной операции используем HTTP-сервер, который запускаем с помощью *python*, а на самой Kali Linux скачиваем файл через утилиту *wget*. После скачивания файла, необходимо выдать ему права на возможность исполнения:

![ScreenShot](screenshots/24.png)

![ScreenShot](screenshots/25.png)

![ScreenShot](screenshots/26.png)

После этого, используя утилиту *r2*, пытаемся узнать пароль. Для начала запускаем непосредственно саму утилиту и в качестве аргумента передаем ей название (путь) файла. Далее запускаем процесс дизассемблирования, что показано на рисунке 27.

![ScreenShot](screenshots/27.png)

Далее при помощи команды *afl* просматриваем функции программы:

![ScreenShot](screenshots/28.png)

После этого просмотрим функцию *sym.compare\_pwd*, которая, судя по названию, как раз-таки сравнивает пароли. Содержимое функции:

![ScreenShot](screenshots/29.png)

Теперь самое важное – работа с дебаггером – переходим на динамический анализ. Вновь откроем файл при помощи команды *ood* с параметров *random* (наш якобы проверяемый пароль). Далее поставим breakpoint на месте перед вызовом функции *strcmp()*. В конце переместимся на нужное место в программе, где как раз фигурирует искомый пароль.

![ScreenShot](screenshots/30.png)

![ScreenShot](screenshots/31.png)

![ScreenShot](screenshots/32.png)

Во все той же программе проверяем найденный пароль:

![ScreenShot](screenshots/33.png)

Как видим, пароль правильный, но куда его применить? Немного поискав, находим архив *machine.zip* в одной из директорий пользователя *vsftp*. Также находим еще несколько файлов. Скачаем данный архив вместе с файлами и исследуем:

![ScreenShot](screenshots/34.png)

![ScreenShot](screenshots/35.png)

![ScreenShot](screenshots/36.png)

![ScreenShot](screenshots/37.png)

![ScreenShot](screenshots/38.png)

![ScreenShot](screenshots/39.png)

В итоге, что мы имеем? У нас был доступ к аккаунту *user*. В директории пользователя *vsftp* у был архив и запись к нему. Проанализировав все данные, получается, что мы нашли приватный SSH-ключ для подключения через УЗ *user*, а не *vsftp*. Что же, получается, мы выполнили лишнее действие, которое результата особого не принесло. Единственная польза – теперь можно подключаться к данному хосту напрямую с Kali Linux, т.к. ключ мы скопировали к себе на машину – для удобства я поместил этот ключ на рабочий стол и переименовал его – <user@92.0.2.254_id_rsa>. Сделал это с учетом того, что у нас могут появиться и другие ключи для подключения:

![ScreenShot](screenshots/40.png)

Как же нам получить привилегированный доступ? Ответ, кончено, неожиданный. Для начала, я думал поменять пароль для УЗ *vsftp* при помощи изменения файла */etc/passwd* (способ будет показан далее на другом хосте), но тут понял, что через УЗ *user* я не могу изменять данный файл. Томить более не стану – пароль от УЗ *vsftp* совпадает с логином. Переход в УЗ *vsftp*:

![ScreenShot](screenshots/41.png)

Так как user-флаг мы уже давно получили, нам необходимо получить root-флаг на этой машине. Самое интересное, что пользователь vsftp имеет возможность исполнять все команды в привилегированном режиме:

![ScreenShot](screenshots/42.png)

Теперь дело за малым – остается только прочитать флаг:

![ScreenShot](screenshots/43.png)

В директории */home/user* в файле *.bash\_history* находим еще одну зацепку – вход по приватному SSH-ключу на хост 92.0.1.1. Сам же ключ находится в директории */home/user/.ssh/*

![ScreenShot](screenshots/44.png)

Проверка возможности входа на хост вышеупомянутый хост.

![ScreenShot](screenshots/45.png)

Для удобства также скачаю приватный ключ к себе на рабочий стол и переименую его – <user@92.0.1.1_id_rsa> (не забываем про *chmod 600*). Сделаю это при помощи открытия *HTTP-сервера на python* и *wget*. Данный способ был представлен ранее при пересылке файла *pass\_manager*.

![ScreenShot](screenshots/46.png)

Найденные флаги на хосте **92.0.2.254**:
- ***User-флаг***: cb6c9a7aeb7cca5cba1462cbf2806086
- ***Root-флаг***: 5e438cbde36f3373c6665d49cf38b61d

---
### Часть 4. ИССЛЕДОВАНИЕ ХОСТА С IP-АДРЕСОМ 92.0.1.1

Для начала стоит обратить внимание на сетевые интерфейсы, список которых представлен ниже на картинке:

![ScreenShot](screenshots/47.png)

Обнаруживаем, что данный хост имеет выход в другую сеть, поэтому можно сделать вывод о том, что он является пограничным маршрутизатором. Собственно, нам нужно получить привилегированный доступ для того, чтобы иметь возможность в дальнейшем попасть в другую подсеть – 10.192.2.0/24. Проверив возможность запуска команд от лица супер-пользователя, понимаем, что мы не может взаимодействовать с sudo вообще

![ScreenShot](screenshots/48.png)

После этого, стоит попробовать найти подобного рода команды с помощью следующей команды: *find / -perm -4000 2>/dev/null*

![ScreenShot](screenshots/49.png)

К сожалению, ничего толкового из этого не получилось, но есть еще один способ. Для этого необходимо проверить возможность редактирования файла */etc/passwd*
  
![ScreenShot](screenshots/50.png)

В чем задумка? В явном присвоении пароля к учетной записи *root*, для возможности дальнейшего входа. Теперь нам необходимо запустить *python3*, импортировать библиотеку *crypt* и воспользоваться одноименной функцией для генерации нового хэша пароля относительно будущего пароля

![ScreenShot](screenshots/51.png)

В качестве пароля у меня будет строка «*pass*». Далее полученную строку необходимо скопировать в файл */etc/passwd*

![ScreenShot](screenshots/52.png)

Сохранив внесенные изменения, можно сменить учетную запись с *user* на *root*

![ScreenShot](screenshots/53.png)

Теперь, когда мы получили полный доступ на хосте, который соединяет две сети, необходимо получить доступ во вторую сеть. Для этого воспользуемся туннелем, который реализуем через SOCKS PROXY с использованием SSH. Для начала необходимо включить службу SSH на нашей Kali Linux:
  
![ScreenShot](screenshots/54.png)

![ScreenShot](screenshots/55.png)

Далее, необходимо отредактировать файл */etc/proxychains4.conf*. Добавим в конце запись, которая представлена ниже, чтобы наша Kali Linux знала, что через порт 8888, прослушивая его, нужно принимать входящий трафик.

![ScreenShot](screenshots/56.png)

Получается, что в данном случае, наша Kali Linux будет выступать в качестве сервера, а не клиента. Теперь по поводу подключения. Предоставляя параметр «-D», SSH будет выступать. как уже упоминалось, в качестве сервера SOCKS и прослушивать указанный в конфигурационном файле порт (8888) для входящих соединений. Процесс активации туннеля представлен на рисунке 57.

![ScreenShot](screenshots/57.png)

После этого, можно выполнить команду *netstat –tunap* и увидеть, что у нас на машине открылся порт 8888 для прослушивания
  
![ScreenShot](screenshots/58.png)

Аналогичную операцию с использованием команды *ss -tunap* можно повторить на стороне клиента:

![ScreenShot](screenshots/59.png)

Тут стоит заметить, что на сетевом интерфейсе у Kali Linux должен быть прописан *default gateway* со значением IP-адреса клиента (92.0.1.1):

![ScreenShot](screenshots/60.png)

При помощи команды *ip r* проверяем введенные изменения. Результат:

![ScreenShot](screenshots/61.png)

В конце проверяем, доступен ли нам второй сетевой интерфейс на маршрутизаторе. Проверка представлена на рисунке 62.

![ScreenShot](screenshots/62.png)

***Примечание***: как я писал ранее, нам нужен был привилегированный доступ к хосту c IP-адресом 92.0.1.1, чтобы впоследствии реализовать доступ ко второй найденной подсети. На самом деле это не совсем так. Можно было бы это все проделать и не имея полного доступа, но в любом случае, нам необходимо иметь хоть какой-то доступ к какой-нибудь УЗ. В нашем случае везение заключается в том, что у нас есть приватный SSH-ключ, т.е. мы имели доступ к УЗ *user*. Просто в тот момент, когда я все это проходил, у меня не было сведений о том, что на этом хосте нет root-флага, т.е. получение супер-пользователя не подразумевалось. Как оказалось, этот хост был «проходным», поэтому на нем не было флагов. Тем не менее, я постарался максимально подробно описать процесс получения привилегий на этом хосте. Как говорится – лучше иметь и не нуждаться, чем нуждаться и не иметь. Простая истина. На данном этапе мы завершаем исследование данного сегмента сети и дальше перейдем к новому, поэтому на рисунке ниже я представлю схему последовательности действий, которые были рассмотрены ранее:

![ScreenShot](screenshots/63.png)

---
### Часть 5. ИССЛЕДОВАНИЕ ХОСТА С IP-АДРЕСОМ 10.192.2.150

Вот мы и получили доступ к другому сегменту сети. Собственно, как и в начале, нам необходимо провести сканирование сети. Делаем это все также при помощи *Nmap*, но при этом используя *proxychains*. Процесс сканирования нового сегмента сети:

![ScreenShot](screenshots/64.png)

Мы нашли только один хост с IP-адресом 10.192.2.150.

![ScreenShot](screenshots/65.png)

![ScreenShot](screenshots/66.png)

Что мы обнаружили? Во-первых, обратим внимание на то, что на целевом хосте открыт *80* порт, где находится *Apache httpd 2.4.38*. Также обратим внимание на порты *10050* и *10051*. *Nmap* определяет их как часть системы мониторинга *Zabbix*.

![ScreenShot](screenshots/67.png)

Раз это, возможно, *Zabbix*, попробуем перейти по стандартному маршруту, т.к. в корневой директории находится *Apache2 Debian Default Page*. Попытка перехода по стандартному пути, где расположена вышеупомянутая система мониторинга:

![ScreenShot](screenshots/68.png)

Для начала всегда пробуем зайти под стандартными логином и паролем. Zabbix по умолчанию имеет следующие данные для авторизации – *Admin*:*zabbix*. Как итог, у нас получается авторизоваться:

![ScreenShot](screenshots/69.png)

Самое интересное, что на Zabbix есть возможность исполнять скрипты на PHP, но для начала будем слушать порт 3344 на Kali:

![ScreenShot](screenshots/70.png)

Процесс создания скрипта на PHP для получения *reverse shell’а*.

![ScreenShot](screenshots/71.png)

Наш скрипт успешно создан:

![ScreenShot](screenshots/72.png)

Запуск скрипта производится по алгоритму, представленному ниже:

![ScreenShot](screenshots/73.png)

Таким образом, мы получаем доступ к терминалу на Zabbix-сервере относительно пользователя *zabbix*:

![ScreenShot](screenshots/74.png)

Нахождение и чтение user-флага на Zabbix-сервере:

![ScreenShot](screenshots/75.png)

Теперь нам необходимо реализовать вертикальное повышение привилегий, чтобы получить доступ к root-флагу. Для начала проверим, имеем ли мы доступ к *sudo*

![ScreenShot](screenshots/76.png)

Далее воспользуемся командой *find / -perm -4000 2>/dev/null*, чтобы посмотреть SUID-файлы, которые доступны нам:

![ScreenShot](screenshots/77.png)

После долгих поисков методов и попыток повышения привилегий был найден простой файл, где содержится пароль от УЗ *root*. 

![ScreenShot](screenshots/78.png)

![ScreenShot](screenshots/79.png)

Теперь мы можем перейти в директорию */root*. Содержимое данной директории:

![ScreenShot](screenshots/80.png)

Сразу проверяем содержимое директории /root/.ssh/ на наличие SSH-ключей:

![ScreenShot](screenshots/81.png)

Далее для удобства при помощью простой команды: *python –c ‘import pty; pty.spawn(“/bin/bash”)’* я активирую bash-оболочку:

![ScreenShot](screenshots/82.png)

Теперь я организую быстрый доступ к хосту с IP-адресом 10.192.2.150. SSH-ключей у нас нет, но у нас есть root-пользователь во владении. В этот раз я просто активирую возможность входа на данный хост по SSH относительно root-пользователя c использованием пароля. Сначала перейдем в директорию */etc/ssh* и активируем HTTP-сервер, чтобы переместить на Kali файл *sshd\_config*.

Казалось бы, зачем перемещать файл и редактировать его на другом хосте, если у нас есть доступ к root-пользователю? Дело в том, что мы изначально использовали *reverse shell* и активировали *bash*, но при этом у нашего пользователя (zabbix) в */etc/passwd* установлен параметр *nologin*:

> Заметка: сам по себе параметр nologin, скорее всего, не сильно играет роль в стабильности оболочки (этот момент надо проработать)

![ScreenShot](screenshots/83.png)

Из-за этого возникают ошибки, которые явно можно заметить на скринах ниже:

![ScreenShot](screenshots/84.png)

![ScreenShot](screenshots/85.png)

Именно из-за этих ошибок трудно редактировать файл, курсор переместить просто невозможно, именно поэтому я принял решение перенести файл к себе на машину. Открытие HTTP-сервера и скачивание файла (после скачивания удаляем файл):

![ScreenShot](screenshots/86.png)

![ScreenShot](screenshots/87.png)

Далее отредактируем скачанный файл – установим параметр *PermitRootLogin* в значение *yes*, чтобы иметь возможность подключаться по SSH через root’а. Также активируем параметр PasswordAuthentication, чтобы подключаться по паролю. Все изменения в файле sshd\_config:

![ScreenShot](screenshots/88.png)

![ScreenShot](screenshots/89.png)

Теперь, наоборот, откроем сервер на Kali Linux, и скачаем файл на Zabbix-сервер:

![ScreenShot](screenshots/90.png)

![ScreenShot](screenshots/91.png)

![ScreenShot](screenshots/92.png)

После этого, перезапускаем службу sshd:

![ScreenShot](screenshots/93.png)

В итоге, мы имеем прямой доступ на хост 10.192.2.150:

![ScreenShot](screenshots/94.png)

После того, как мы закрепились на хосте с Zabbix’ом, пробуем пробиться дальше. Посмотрим сетевые интерфейсы:

![ScreenShot](screenshots/95.png)

Построим GRE-туннель между нашей Kali Linux и Zabbix. Для начала активируем модуль, отвечающий за возможность создания GRE-туннеля:

![ScreenShot](screenshots/96.png)

В случае чего, добавив к команде флаг *–r* можно деактивировать данный модуль. Активацию модуля необходимо провести на обеих машинах. Далее редактируем GRE-интерфейс на Kali Linux и выключаем/включаем его для применения настроек:

![ScreenShot](screenshots/97.png)

Проверяем параметры:

![ScreenShot](screenshots/98.png)

Редактируем GRE-интерфейс на Zabbix и выключаем/включаем его для применения настроек:

![ScreenShot](screenshots/99.png)

Проверяем параметры на Zabbix:

![ScreenShot](screenshots/100.png)

Проверяем прямую доступность до Zabbix:

![ScreenShot](screenshots/101.png)

Проверим маршруты – дефолтный маршрут, относящийся к GRE-туннелю должен иметь больший приоритет:

![ScreenShot](screenshots/102.png)

Добавляем маршрут, чтобы Kali понимала, что скрывается за туннелем и могла дотянуться до сети 10.192.3.0/24 – без этого не будет работать:

![ScreenShot](screenshots/103.png)

На всякий случай проверяем, что все интерфейсы в порядке:

![ScreenShot](screenshots/104.png)

Проверяем возможность дотянуться до сети 10.192.3.0/24

![ScreenShot](screenshots/105.png)

Делаем второй SSH-туннель (параллельно уже существующему, видно будет дальше):

![ScreenShot](screenshots/106.png)

Активные туннельные соединения:

![ScreenShot](screenshots/107.png)

Настройки в файле */etc/proxychains4.conf*:

![ScreenShot](screenshots/108.png)

> Могу предположить, что параллельно создавать SSH-туннели не надо, т.к. у нас есть GRE-туннель, но утверждать не могу

Активируем параметр *net.ipv4.ip\_forward=1* для возможности пересылки пакетов между сетевыми интерфейсами:

![ScreenShot](screenshots/109.png)

Проверяем активацию:

![ScreenShot](screenshots/110.png)

> Заканчиваем раздел. Тут добавлю, что при прохождении данного стенда я записал себе, что на Zabbix-сервере ввел такую команду: **sudo iptables -t nat -A POSTROUTING -o gre40 -j MASQUERADE**. Я, честно сказать, до сих пор не могу понять, помогла ли мне эта команда каким-либо образом или нет :)

Найденные флаги на хосте **10.192.2.150**:
- ***Флаг***: 6031dfa4ef78ed670e8451375168abc3 

---
### Часть 6. ИССЛЕДОВАНИЕ ХОСТА С IP-АДРЕСОМ 10.192.3.55

Сканируем новый сегмент сети - **10.192.3.0/24**:

![ScreenShot](screenshots/111.png)

Проверяем прямую доступность до найденного хоста с IP-адресом **10.192.3.55**:

![ScreenShot](screenshots/112.png)

Сканируем более детально найденный хост:

![ScreenShot](screenshots/113.png)

Из интересного - сразу замечаем 3 открытых HTTP-порта (80, 8000, 8080). На порте 80 находится форма для загрузки файлов:

![ScreenShot](screenshots/114.png)

Тоже самое на порте 8080:

![ScreenShot](screenshots/115.png)

А на порте 8000 видим просто текст:

![ScreenShot](screenshots/116.png)

Тут сразу приходит в голову идея по загрузке скрипта, который позволит реализовать Reverse Shell. Собственно, подготавливаем файл:

![ScreenShot](screenshots/117.png)

![ScreenShot](screenshots/118.png)

Слушаем порт 4444, куда будет производиться подключение со стороны жертвы:

![ScreenShot](screenshots/119.png)

При попытке загрузить подготовленный файл (на сервис, который находится на порте 80) получаем ошибку, которая говорит, что тип файла не верный:

![ScreenShot](screenshots/120.png)

![ScreenShot](screenshots/121.png)

Пробуем поменять расширение на *.phtml*:

![ScreenShot](screenshots/122.png)

![ScreenShot](screenshots/123.png)

В итоге ошибка сохраняется, попробуем поискать что-то другое. Спустя некоторое время на сервисе, расположенном на порте 8000, находим **path traversal**:

![ScreenShot](screenshots/124.png)

![ScreenShot](screenshots/125.png)

![ScreenShot](screenshots/126.png)

> Тут вопрос возникает - откуда я узнал про пользователя? Хе-хе, секрет! Но, да, скажу честно, стенд хотели закрывать, поэтому я спешил и брал подсказки, смотрел некоторые вектора и т.д. Тем не менее, чуть дальше будет рассмотрено получение reverse-shell'а, где, по факту, пользователь и не нужен

На сервисе, который расположен на 80 порте, находим загруженные файлы:

![ScreenShot](screenshots/127.png)

![ScreenShot](screenshots/128.png)

Получаем исходный код файла, который обрабатывает загрузку файла:

![ScreenShot](screenshots/129.png)

![ScreenShot](screenshots/130.png)

> Payload: http://10.192.3.55:8000/index.php?page=php://filter/convert.base64-encode/resource=/var/www/html/process-form.php

Часть кода:

![ScreenShot](screenshots/131.png)

![ScreenShot](screenshots/132.png)

Сильно толкового ничего не нашли, но зато по другим загрузкам (файлам с расширением .gif) узнаем, что форма пропускает файлы с расширением .gif. Видоизменяем наш скрипт для Reverse Shell'а

![ScreenShot](screenshots/133.png)

![ScreenShot](screenshots/134.png)

Загружаем файл:

![ScreenShot](screenshots/135.png)

![ScreenShot](screenshots/136.png)

Файл загружен! 

![ScreenShot](screenshots/137.png)

Активируем загруженный файл:

![ScreenShot](screenshots/138.png)

![ScreenShot](screenshots/139.png)

Читаем второй флаг:

![ScreenShot](screenshots/140.png)

Найденные флаги на хосте **10.192.2.150**:
- ***Флаг***: 0ecbc5bc737d2a90659e3d53a178fab7

Далее вызываем bash-оболочку при помощи Python:

![ScreenShot](screenshots/141.png)

Теперь перейдем к изучению следующего сегмента сети.

---
### Часть 7. ИССЛЕДОВАНИЕ ХОСТА С IP-АДРЕСОМ 10.192.4.1

Исследуем сетевые интерфейсы ранее захваченного хоста:

![ScreenShot](screenshots/142.png)

Находим новый сегмент сети - **10.192.4.0/24**. Также находим на ранее захваченном хосте файлы с SSH-ключами:

![ScreenShot](screenshots/143.png)

Теперь настраиваем SSH-сервер на захваченном хосте:

![ScreenShot](screenshots/144.png)

![ScreenShot](screenshots/145.png)

![ScreenShot](screenshots/146.png)

![ScreenShot](screenshots/147.png)

![ScreenShot](screenshots/148.png)

Проверяем доступ:

![ScreenShot](screenshots/149.png)

Чтобы иметь возможность продвигаться дальше, делаем очередной SSH-туннель:

![ScreenShot](screenshots/150.png)

Активируем пересылку пакетов между сетевыми интерфейсами:

![ScreenShot](screenshots/151.png)

![ScreenShot](screenshots/152.png)

![ScreenShot](screenshots/153.png)

Оставлю перечень туннелей и маршрутов:

![ScreenShot](screenshots/154.png)

![ScreenShot](screenshots/155.png)

Проверяем прямую доступность до хоста 10.192.4.1 и видим, что ping не идет. При этом, сам хост живой:

![ScreenShot](screenshots/156.png)

![ScreenShot](screenshots/157.png)

Попробуем просканировать хост при помощи Nmap и флага -sT:

![ScreenShot](screenshots/158.png)

Видим открытый SSH-порт 2222. Проверим, можем ли мы подключиться при помощи ключей, которые лежат на последнем захваченном хосте:

![ScreenShot](screenshots/159.png)

Отлично! Можем, сразу проверить сетевые интерфейсы:

![ScreenShot](screenshots/160.png)

Далее переносим ключи с PHP-srv на Kali, чтобы мы могли подключаться напрямую:

![ScreenShot](screenshots/161.png)

![ScreenShot](screenshots/162.png)

![ScreenShot](screenshots/163.png)

![ScreenShot](screenshots/164.png)

Проверяем подключение:

![ScreenShot](screenshots/165.png)

Учитываем, что нам нужен PortForwarding на 10.192.3.55 - без него нельзя дотянуться до 4.1:

![ScreenShot](screenshots/166.png)

![ScreenShot](screenshots/167.png)

![ScreenShot](screenshots/168.png)

---
